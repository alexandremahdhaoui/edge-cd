package gitserver

import (
	_ "embed"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/alexandremahdhaoui/edge-cd/pkg/cloudinit"
	"github.com/alexandremahdhaoui/edge-cd/pkg/ssh"
	"github.com/alexandremahdhaoui/edge-cd/pkg/vmm"
)

//go:embed Dockerfile
var Dockerfile string

//go:embed entrypoint.sh
var Entrypoint string

type SourceType int

const (
	LocalSource SourceType = iota
	GitUrlSource
)

type Source struct {
	Type      SourceType
	LocalPath string
	GitUrl    string
}

type Repo struct {
	Name   string
	Source Source
}

type Server struct {
	ServerAddr     string
	SSHPort        int
	HostKeyPath    string
	AuthorizedKeys []string
	BaseDir        string
	Repo           []Repo

	// -- VM related fields
	vmm               *vmm.VMM
	vmConfig          vmm.VMConfig
	vmIPAddress       string
	sshPrivateKeyPath string // Path to the Git server VM's SSH private key (generated by initVM)
	sshPublicKeyPath  string // Path to the Git server VM's SSH public key (generated by initVM)
	tempDir           string // Temporary directory for SSH keys and other temporary files
	imageQCOW2Path    string // Path to the base QCOW2 image for the VM

	// -- Docker related fields (to be removed later)
	authorizedKeysFile string
	buildDir           string
	gitDir             string
	imgName            string
	runningContainer   string
}

func NewServer(baseDir, imageQCOW2Path string, repo []Repo) *Server {
	return &Server{
		ServerAddr:     "localhost",
		SSHPort:        22,
		HostKeyPath:    filepath.Join(baseDir, "id_rsa_host_client"),
		AuthorizedKeys: []string{},
		BaseDir:        baseDir,
		Repo:           repo,
		tempDir:        baseDir,
		imageQCOW2Path: imageQCOW2Path,
	}
}

func (s *Server) Run() error {
	if err := s.init(); err != nil {
		return fmt.Errorf("failed to initialize git server: %v", err)
	}

	if err := s.initVM(); err != nil {
		return fmt.Errorf("failed to initialize VM: %v", err)
	}

	var err error
	s.vmm, err = vmm.NewVMM()
	if err != nil {
		return fmt.Errorf("failed to create VMM: %v", err)
	}

	if _, err := s.vmm.CreateVM(s.vmConfig); err != nil {
		return fmt.Errorf("failed to create VM: %v", err)
	}

	s.vmIPAddress, err = s.vmm.GetVMIPAddress(s.vmConfig.Name)
	if err != nil {
		return fmt.Errorf("failed to get VM IP address: %v", err)
	}
	s.ServerAddr = s.vmIPAddress

	// -- init ssh client
	sshClient, err := s.sshClient()
	if err != nil {
		return fmt.Errorf("failed to ssh to git server: %w", err)
	}

	for _, repo := range s.Repo {
		srcPath, err := s.fetchRepo(repo)
		if err != nil {
			return fmt.Errorf("failed to start fetch git repo: %w", err)
		}

		if err := s.initAndPushRepo(sshClient, repo.Name, srcPath); err != nil {
			return fmt.Errorf("failed to init repo: %w", err)
		}
	}

	return nil
}

func (s *Server) init() error {
	s.imgName = "gitserver"
	baseDir := s.BaseDir
	if baseDir == "" {
		var err error
		baseDir, err = os.MkdirTemp("", "git-server")
		if err != nil {
			return err
		}
	}
	// Initialize tempDir if it's not already set (e.g., by a test)
	if s.tempDir == "" {
		s.tempDir = baseDir
	}

	sshDir := filepath.Join(baseDir, "ssh")
	s.authorizedKeysFile = filepath.Join(sshDir, "authorized_keys")
	s.buildDir = filepath.Join(s.BaseDir, "build")
	s.gitDir = filepath.Join(s.BaseDir, "git")
	for _, dir := range []string{sshDir, s.buildDir, s.gitDir} {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}
	return nil
}

// initVM prepares the vmm.VMConfig and cloudinit.UserData for the Git server VM.
func (s *Server) initVM() error {
	// 1. Generate a new SSH key pair for the Git server VM
	s.sshPrivateKeyPath = filepath.Join(s.tempDir, "id_rsa_gitserver")
	s.sshPublicKeyPath = s.sshPrivateKeyPath + ".pub"

	cmd := exec.Command("ssh-keygen", "-t", "rsa", "-b", "2048", "-f", s.sshPrivateKeyPath, "-N", "")
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to generate SSH key pair for Git server VM: %w\nOutput: %s", err, output)
	}
	if err := os.Chmod(s.sshPrivateKeyPath, 0o600); err != nil {
		return fmt.Errorf("failed to set permissions on Git server VM SSH private key: %v", err)
	}

	// 2. Configure cloud-init UserData
	publicKeyBytes, err := os.ReadFile(s.sshPublicKeyPath)
	if err != nil {
		return fmt.Errorf("failed to read Git server VM SSH public key: %w", err)
	}
	
	authorizedKeys := append(s.AuthorizedKeys, strings.TrimSpace(string(publicKeyBytes)))

	gitUser := cloudinit.NewUserWithAuthorizedKeys("git", authorizedKeys)
	if err != nil {
		return fmt.Errorf("failed to create cloud-init user for Git server VM: %w", err)
	}

	userData := cloudinit.UserData{
		Hostname:      s.imgName, // Using imgName as VM name
		PackageUpdate: true,
		Packages:      []string{"git", "openssh-server", "qemu-guest-agent"},
		Users:         []cloudinit.User{gitUser},
		RunCommands: []string{
			"mkdir -p /srv/git",
			"chsh -s /usr/bin/git-shell git",
			"sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config",
			"sed -i 's/^PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config",
			"sed -i 's/^#PermitRootLogin prohibit-password/PermitRootLogin no/' /etc/ssh/sshd_config",
			"sed -i 's/^PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config",
			"systemctl restart sshd",
		},
	}

	// 3. Populate s.vmConfig
	s.vmConfig = vmm.NewVMConfig(s.imgName, s.imageQCOW2Path, userData)

	return nil
}

func (s *Server) buildImage() error {
	dockerfilePath := filepath.Join(s.buildDir, "Dockerfile")
	if err := os.WriteFile(dockerfilePath, []byte(Dockerfile), 0o644); err != nil {
		return err
	}
	entrypointPath := filepath.Join(s.buildDir, "entrypoint.sh")
	if err := os.WriteFile(entrypointPath, []byte(Entrypoint), 0o644); err != nil {
		return err
	}
	// Build the Git server Docker image
	cmd := exec.Command(
		"docker",
		"build",
		"-t",
		s.imgName,
		".", // Build from the current directory (s.buildDir)
	)
	cmd.Dir = s.buildDir // Set the working directory for the command
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func (s *Server) setupAuthorizedKeys() error {
	// Write public keys to authorized_keys
	authKeysContent := strings.Join(s.AuthorizedKeys, "\n")
	authKeysPath := s.authorizedKeysFile
	if err := os.WriteFile(authKeysPath, []byte(authKeysContent), 0o644); err != nil {
		return fmt.Errorf("failed to write authorized_keys: %w", err)
	}

	return nil
}

func (s *Server) start() error {
	// Run the Git server container
	containerName := fmt.Sprintf("gitserver-%d", time.Now().UnixNano())
	cmd := exec.Command(
		"docker", "run", "-d",
		"--name", containerName,
		"-p", fmt.Sprintf("%d:22", s.SSHPort),
		"-v", fmt.Sprintf("%s:/srv/git:ro", s.gitDir),
		"-v", fmt.Sprintf("%s:/tmp/authorized_keys:ro", s.authorizedKeysFile),
		s.imgName,
	)
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return err
	}
	s.runningContainer = containerName
	return nil
}

func (s *Server) Teardown() error {
	if s.vmm == nil {
		return nil // Nothing to do if VMM was not initialized
	}

	var errs error
	if err := s.vmm.DestroyVM(s.vmConfig.Name); err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to destroy VM: %w", err))
	}

	if err := s.vmm.Close(); err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to close VMM connection: %w", err))
	}

	if err := os.RemoveAll(s.tempDir); err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to remove temp dir: %w", err))
	}

	if errs != nil {
		slog.Error("encountered unexpected error while tearing down git server", "error", errs.Error())
	}

	return errs
}

func (s *Server) sshClient() (*ssh.Client, error) {
	sshClient, err := ssh.NewClient(s.ServerAddr, "git", s.HostKeyPath, fmt.Sprintf("%d", s.SSHPort))
	if err != nil {
		return nil, fmt.Errorf("failed to create SSH client for Git server: %w", err)
	}
	if err := sshClient.AwaitServer(30 * time.Second); err != nil {
		return nil, fmt.Errorf("Git server did not become ready in time: %w", err)
	}
	return sshClient, nil
}

func (s *Server) fetchRepo(repo Repo) (string, error) {
	switch repo.Source.Type {
	default:
		panic("not implemented")
	case LocalSource:
		return filepath.Join(s.gitDir, repo.Name), nil
	case GitUrlSource:
		panic("not implemented either")
	}
}

func (s *Server) initAndPushRepo(sshClient *ssh.Client, repoName, srcPath string) error {
	// Initialize a bare Git repository on the server
	initCmd := fmt.Sprintf("git init --bare /srv/git/%s", repoName)
	if _, _, err := sshClient.Run(initCmd); err != nil {
		return fmt.Errorf("failed to initialize bare repository on Git server: %w", err)
	}

	destPath := filepath.Join(s.gitDir, repoName)
	cmd := exec.Command("cp", "-r", filepath.Join(srcPath, "."), destPath)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to copy package manager configs: %w\nOutput: %s", err, output)
	}

	if err := os.RemoveAll(filepath.Join(destPath, ".git")); err != nil {
		return err
	}

	// Initialize local git repo and push
	cmd = exec.Command("git", "init")
	cmd.Dir = destPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to git init local repo: %w\nOutput: %s", err, output)
	}

	cmd = exec.Command("git", "add", ".")
	cmd.Dir = destPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to git add local repo: %w\nOutput: %s", err, output)
	}

	cmd = exec.Command("git", "commit", "-m", "Initial commit")
	cmd.Dir = destPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to git commit local repo: %w\nOutput: %s", err, output)
	}

	cmd = exec.Command("git", "remote", "add", "origin", s.GetRepoUrl(repoName))
	cmd.Dir = destPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to add git remote: %w\nOutput: %s", err, output)
	}

	cmd = exec.Command("git", "push", "-u", "origin", "main")
	cmd.Dir = destPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to git push to remote: %w\nOutput: %s", err, output)
	}

	return nil
}

func (s *Server) GetRepoUrl(repoName string) string {
	return fmt.Sprintf("ssh://git@%s/srv/git/%s", s.ServerAddr, repoName)
}

func (s *Server) GetVMIPAddress() string {
	return s.vmIPAddress
}
