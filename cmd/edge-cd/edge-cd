#!/bin/sh
#
# Copyright 2025 Alexandre Mahdhaoui
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

[ -f /etc/shinit ] && . /etc/shinit

set -e
set -u
set -x

# ----------------------------------------------------------------
# Imports
# ----------------------------------------------------------------

SRC_DIR="${SRC_DIR:-$(dirname "$(readlink -f "$0")")}"
LIB_DIR="${SRC_DIR}/lib"

# -- The 2 variables below are "injected" into the pkgmgr and
#    svcmgr lib files.
PKGMGR_DIR="${SRC_DIR}/package-managers"
SVCMGR_DIR="${SRC_DIR}/service-managers"

[ -z "${__LOADED_LIB_CONFIG:-}" ] && . "${LIB_DIR}/config.sh"
[ -z "${__LOADED_LIB_LOCK:-}" ] && . "${LIB_DIR}/lock.sh"
[ -z "${__LOADED_LIB_LOG:-}" ] && . "${LIB_DIR}/log.sh"
[ -z "${__LOADED_LIB_PKGMGR:-}" ] && . "${LIB_DIR}/pkgmgr.sh"
[ -z "${__LOADED_LIB_SVCMGR:-}" ] && . "${LIB_DIR}/svcmgr.sh"

# ----------------------------------------------------------------
# General config
# ----------------------------------------------------------------
# If config, edge-cd.sh or edge-cd.service files change we restart
# the process (exit 0)
#
# Please note that CONFIG_PATH must be specifed

__DEFAULT_EDGE_CD_REPO_BRANCH=main
__DEFAULT_EDGE_CD_REPO_DESTINATION_PATH=/usr/local/src/edge-cd
__DEFAULT_EDGE_CD_REPO_URL=https://github.com/alexandremahdhaoui/edge-cd.git

__DEFAULT_EDGE_CD_COMMIT_PATH=/tmp/edge-cd/edge-cd-last-synchronized-commit.txt
__DEFAULT_CONFIG_COMMIT_PATH=/tmp/edge-cd/config-last-synchronized-commit.txt

__DEFAULT_CONFIG_REPO_BRANCH=main
__DEFAULT_CONFIG_REPO_DEST_PATH=/usr/local/src/edge-cd-config
__DEFAULT_CONFIG_SPEC_FILE=spec.yaml

declare_config() {
	# Variables are implicitly declared in POSIX shell
	# This function serves as documentation of expected variables
	:
}

init_config() {
	# First, initialize the critical variables needed for get_config_spec_abspath()
	# These need to be set before set_extra_envs() is called
	CONFIG_SPEC_FILE="${CONFIG_SPEC_FILE:-${__DEFAULT_CONFIG_SPEC_FILE}}"
	CONFIG_REPO_DEST_PATH="${CONFIG_REPO_DEST_PATH:-${__DEFAULT_CONFIG_REPO_DEST_PATH}}"

	# CONFIG_PATH must be provided - no default
	if [ -z "${CONFIG_PATH}" ]; then
		echo "[ERROR] CONFIG_PATH environment variable must be set" >&2
		exit 1
	fi

	# Now we can safely call set_extra_envs since the path variables are initialized
	set_extra_envs

	# -- user config
	__BACKUP_CONFIG_PATH="${CONFIG_PATH}"
	__BACKUP_CONFIG_SPEC_FILE="$(read_value CONFIG_SPEC_FILE '.config.spec' "${__DEFAULT_CONFIG_SPEC_FILE}")"
	__BACKUP_CONFIG_REPO_BRANCH="$(read_value CONFIG_REPO_BRANCH '.config.repo.branch' "${__DEFAULT_CONFIG_REPO_BRANCH}")"
	__BACKUP_CONFIG_REPO_DEST_PATH="$(read_value CONFIG_REPO_DEST_PATH '.config.repo.destPath' "${__DEFAULT_CONFIG_REPO_DEST_PATH}")"
	__BACKUP_CONFIG_REPO_URL="$(read_value CONFIG_REPO_URL '.config.repo.url')"

	# -- edge config
	__BACKUP_EDGE_CD_REPO_BRANCH="$(read_value EDGE_CD_REPO_BRANCH '.edgeCD.repo.branch' "${__DEFAULT_EDGE_CD_REPO_BRANCH}")"
	__BACKUP_EDGE_CD_REPO_DESTINATION_PATH="$(read_value EDGE_CD_REPO_DESTINATION_PATH '.edgeCD.repo.destinationPath' "${__DEFAULT_EDGE_CD_REPO_DESTINATION_PATH}")"
	__BACKUP_EDGE_CD_REPO_URL="$(read_value EDGE_CD_REPO_URL '.edgeCD.repo.url' "${__DEFAULT_EDGE_CD_REPO_URL}")"

	__BACKUP_EDGE_CD_COMMIT_PATH="$(read_value EDGE_CD_COMMIT_PATH '.edgeCD.commitPath' "${__DEFAULT_EDGE_CD_COMMIT_PATH}")"
	__BACKUP_CONFIG_COMMIT_PATH="$(read_value CONFIG_COMMIT_PATH '.config.commitPath' "${__DEFAULT_CONFIG_COMMIT_PATH}")"
}

reset_config() {
	reset_extra_envs

	CONFIG_PATH="${__BACKUP_CONFIG_PATH}"
	CONFIG_SPEC_FILE="${__BACKUP_CONFIG_SPEC_FILE}"

	CONFIG_REPO_BRANCH="${__BACKUP_CONFIG_REPO_BRANCH}"
	CONFIG_REPO_DEST_PATH="${__BACKUP_CONFIG_REPO_DEST_PATH}"
	CONFIG_REPO_URL="${__BACKUP_CONFIG_REPO_URL}"

	EDGE_CD_REPO_BRANCH="${__BACKUP_EDGE_CD_REPO_BRANCH}"
	EDGE_CD_REPO_DESTINATION_PATH="${__BACKUP_EDGE_CD_REPO_DESTINATION_PATH}"
	EDGE_CD_REPO_URL="${__BACKUP_EDGE_CD_REPO_URL}"

	EDGE_CD_COMMIT_PATH="${__BACKUP_EDGE_CD_COMMIT_PATH}"
	CONFIG_COMMIT_PATH="${__BACKUP_CONFIG_COMMIT_PATH}"
}

# ----------------------------------------------------------------
# R(un)T(ime) V(ariables) (RTV_)
# ----------------------------------------------------------------

declare_runtime_variables() {
	# Variables are implicitly declared in POSIX shell
	:
}

reset_runtime_variables() {
	RTV_REQUIRE_SERVICE_RESTART=""
	RTV_REQUIRE_SELF_RESTART=false
	RTV_REQUIRE_REBOOT=false
}

# ----------------------------------------------------------------
# EdgeCD repo
# ----------------------------------------------------------------

clone_repo_edge_cd() {
	logInfo "Cloning EdgeCD repo"
	git clone --filter=blob:none --no-checkout "${EDGE_CD_REPO_URL}" "${EDGE_CD_REPO_DESTINATION_PATH}"

	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout init
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout set "cmd/edge-cd"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" checkout "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" fetch origin "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" pull
}

sync_repo_edge_cd() {
	logInfo "Pulling EdgeCD repo"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout set "cmd/edge-cd"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" fetch origin "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" reset --hard FETCH_HEAD
}

# ----------------------------------------------------------------
# Config repo
# ----------------------------------------------------------------

clone_repo_config() {
	case "${CONFIG_REPO_URL}" in
		file://*)
			logInfo "Using local file-based repository for config. This is a non-production option. Skipping git clone."
			return 0
			;;
	esac
	logInfo "Cloning config repo"
	git clone --filter=blob:none --no-checkout "${CONFIG_REPO_URL}" "${CONFIG_REPO_DEST_PATH}"

	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout init
	# Set sparse-checkout to include the config path directory
	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout set "${CONFIG_PATH}"
	git -C "${CONFIG_REPO_DEST_PATH}" checkout "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" fetch origin "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" pull
}

sync_repo_config() {
	case "${CONFIG_REPO_URL}" in
		file://*)
			logInfo "Using local file-based repository for config. This is a non-production configuration option. Skipping git pull."
			return 0
			;;
	esac
	logInfo "Pulling config repo"
	# Set sparse-checkout to include the config path directory
	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout set "${CONFIG_PATH}"
	git -C "${CONFIG_REPO_DEST_PATH}" fetch origin "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" reset --hard FETCH_HEAD
}

# ----------------------------------------------------------------
# reconcile_files
# ----------------------------------------------------------------

__reconcile_file() {
	srcPath="$1"
	destPath="$2"
	fileMod="$3"
	restartServices="$4"
	requireReboot="$5"

	# -- validate inputs
	if [ -z "${srcPath}" ] || [ "${srcPath}" = "null" ]; then
		logErr "srcPath must be specified"
		exit 1
	fi

	if [ -z "${destPath}" ] || [ "${destPath}" = "null" ]; then
		logErr "srcPath must be specified"
		exit 1
	elif ! echo "${destPath}" | grep -q '^/'; then
		logErr "destPath must be an absolute path"
		exit 1
	fi

	# -- set defaults
	if [ -z "${fileMod}" ] || [ "${fileMod}" = "null" ]; then fileMod=644; fi
	if [ "${restartServices}" = "null" ]; then restartServices=""; fi

	# -- compare src and dest
	if cmp "${srcPath}" "${destPath}" 2>/dev/null; then
		return 0
	fi

	logInfo "Drift detected: updating file \"${destPath}\""
	mkdir -p "$(dirname "${destPath}")"
	# mark associated service for restart
	services_to_restart=$(echo "${restartServices}" | yq -e -r '.[]' 2>/dev/null || true)
	if [ -n "${services_to_restart}" ]; then
		RTV_REQUIRE_SERVICE_RESTART="${RTV_REQUIRE_SERVICE_RESTART}${services_to_restart}
"
	fi

	# -- set require reboot flag
	if [ "${requireReboot}" = "true" ]; then
		RTV_REQUIRE_REBOOT=true
	fi

	cp -f "${srcPath}" "${destPath}"
	chmod "${fileMod}" "${destPath}"
}

__reconcile_file_mux() {
	fileSpec="$1"

	type="$(read_yaml_stdin '.type' "${fileSpec}")"

	case "${type}" in
		file | directory)
			srcPath="$(read_yaml_stdin '.srcPath' "${fileSpec}")"
			;;
		content)
			content="$(read_yaml_stdin '.content' "${fileSpec}")"
			;;
		*)
			logErr "Unknown type=\"${type}\" for destPath=\"${destPath}\""
			exit 1
			;;
	esac

	destPath="$(read_yaml_stdin '.destPath' "${fileSpec}")"
	fileMod="$(read_yaml_stdin_optional '.fileMod' "${fileSpec}")"
	restartServices="$(read_yaml_stdin_optional '.syncBehavior.restartServices' "${fileSpec}")"
	requireReboot="$(read_yaml_stdin_optional '.syncBehavior.reboot' "${fileSpec}")"

	# TODO: Add a "git" type? E.g.: clone any repo and copy file from repo to the dest
	case "${type}" in
		file)
			srcPath="${CONFIG_REPO_DEST_PATH}/${CONFIG_PATH}/${srcPath}"
			;;

		# -- directory does not support recursive
		directory)
			dir_files=$(find "${srcPath}" -type f ! -name '\.*' -exec readlink -f {} \;)
			if [ -n "${dir_files}" ]; then
				while IFS= read -r srcPath || [ -n "$srcPath" ]; do
					[ -z "${srcPath}" ] && continue
					__reconcile_file "${srcPath}" "${destPath}" "${fileMod}" "${restartServices}" "${requireReboot}"
				done <<EOF
${dir_files}
EOF
			fi
			# -- directory returns early
			return
			;;

		content)
			# -- type content
			srcPath="$(mktemp)"
			printf '%s\n' "${content}" >"${srcPath}"
			;;

		*)
			logErr "Unknown type=\"${type}\" for destPath=\"${destPath}\""
			exit 1
			;;
	esac

	# -- sync file
	__reconcile_file "${srcPath}" "${destPath}" "${fileMod}" "${restartServices}" "${requireReboot}"
}

# ----------------------------------------------------------------
# sync_file_list
# ----------------------------------------------------------------

reconcile_files() {
	logInfo "Reconciling files"

	files_json=$(yq e -o=j -I=0 '.files[]' "$(get_config_spec_abspath)" 2>/dev/null || true)
	if [ -n "${files_json}" ]; then
		while IFS= read -r fileSpec || [ -n "$fileSpec" ]; do
			[ -z "${fileSpec}" ] && continue
			__reconcile_file_mux "${fileSpec}"
		done <<EOF
${files_json}
EOF
	fi
}

# ----------------------------------------------------------------
# sync_edge_cd
# ----------------------------------------------------------------

reconcile_edge_cd() {
	logInfo "Reconciling EdgeCD"

	name=edge-cd

	# -- Get last synced commit and current commit
	lastCommit=$(cat "${EDGE_CD_COMMIT_PATH}" 2>/dev/null || echo "")
	currentCommit="$(git -C "${EDGE_CD_REPO_DESTINATION_PATH}" rev-parse HEAD)"

	# -- Check if edge-cd script has changed between commits
	if [ -n "${lastCommit}" ] && [ "${lastCommit}" != "${currentCommit}" ]; then
		if git -C "${EDGE_CD_REPO_DESTINATION_PATH}" diff --name-only "${lastCommit}" "${currentCommit}" | grep -q "^cmd/edge-cd/edge-cd$"; then
			logInfo "EdgeCD script has changed, marking service for restart"
			RTV_REQUIRE_SERVICE_RESTART="${RTV_REQUIRE_SERVICE_RESTART}${name}
"
		fi
	fi

	# -- Ensure edge-cd service is always enabled (if service file exists)
	if [ -f "/etc/init.d/${name}" ]; then
		enable_service "${name}"
	else
		logInfo "Service file /etc/init.d/${name} does not exist, skipping service enable"
	fi

	# -- Commit this change
	mkdir -p "$(dirname "${EDGE_CD_COMMIT_PATH}")"
	echo "${currentCommit}" >"${EDGE_CD_COMMIT_PATH}"
}

# ----------------------------------------------------------------
# checkCommit
# ----------------------------------------------------------------

is_commit_in_sync() {
	case "${CONFIG_REPO_URL}" in
		file://*)
			logInfo "Using local file-based repository for config. Skipping commit synchronization."
			return 1 # Return non-zero status to signal skip
			;;
	esac

	lastCommit=$(cat "${CONFIG_COMMIT_PATH}" 2>/dev/null || echo "")
	currentCommit="$(git -C "${CONFIG_REPO_DEST_PATH}" rev-parse HEAD)"

	if [ "${lastCommit}" = "${currentCommit}" ]; then
		logInfo "Skipping synchronization: user config is already in sync with commit ${currentCommit}"
		return 1 # Return non-zero status to signal skip
	fi

	logInfo "Starting configuration synchronization for commit ${currentCommit}"
}

commit_last_change() {
	currentCommit="$(git -C "${CONFIG_REPO_DEST_PATH}" rev-parse HEAD)"
	echo "${currentCommit}" >"${CONFIG_COMMIT_PATH}"
	logInfo "Synced commit \"${currentCommit}\" successfully"
}

# ----------------------------------------------------------------
# polling_backoff
# ----------------------------------------------------------------

polling_backoff() {
	sleepTime="$(read_config '.pollingIntervalSecond' || echo "")"
	if [ -z "${sleepTime}" ]; then
		logWarn "Failed to read pollingIntervalSecond from config: Sleeping 60s" >&2
		sleepTime=60
	fi

	logInfo "Sleeping for ${sleepTime} seconds"
	sleep "${sleepTime}"
}

# ----------------------------------------------------------------
# Reconcile
# ----------------------------------------------------------------

reconcile() {
	[ -d "${EDGE_CD_REPO_DESTINATION_PATH}" ] || clone_repo_edge_cd
	sync_repo_edge_cd

	[ -d "${CONFIG_REPO_DEST_PATH}" ] || clone_repo_config
	sync_repo_config

	# Check if the repository has been updated since the last
	# successful sync.
	if ! is_commit_in_sync; then
		# only re-install packages on new commits as drift detection
		# is not yet implemented
		reconcile_packages
	fi

	reconcile_package_auto_upgrade
	reconcile_edge_cd
	reconcile_files

	# -- Reboot if flag set
	if [ "${RTV_REQUIRE_REBOOT}" = "true" ]; then
		logInfo "Rebooting now"
		reboot
	fi

	# -- restart services
	# Use heredoc to avoid subshell issue with pipe
	services_list=$(printf '%s\n' "${RTV_REQUIRE_SERVICE_RESTART}" | grep -v '^\s*$' | sort | uniq)
	if [ -n "${services_list}" ]; then
		while IFS= read -r service || [ -n "$service" ]; do
			[ -z "${service}" ] && continue
			enable_service "${service}"
			restart_service "${service}"
		done <<EOF
${services_list}
EOF
	fi
}

# ----------------------------------------------------------------
# main
# ----------------------------------------------------------------

main() {
	lock
	trap unlock EXIT

	declare_runtime_variables
	declare_config
	init_config
	set_extra_envs

	while true; do
		reset_config
		reset_extra_envs
		reset_runtime_variables

		reconcile

		polling_backoff
	done
}

main
