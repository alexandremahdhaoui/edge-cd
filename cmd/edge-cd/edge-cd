#!/usr/bin/env bash
#
# Copyright 2025 Alexandre Mahdhaoui
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

. /etc/shinit

set -o errexit
set -o nounset
set -o pipefail
set -o xtrace

# ----------------------------------------------------------------
# Imports
# ----------------------------------------------------------------

SRC_DIR="${SRC_DIR:-$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")}"
LIB_DIR="${SRC_DIR}/lib"
PKGMGR_DIR="${SRC_DIR}/package-managers"
SVCMGR_DIR="${SRC_DIR}/service-managers"

[ -z "${__LOADED_LIB_CONFIG:-}" ] && . "${LIB_DIR}/config.sh"
[ -z "${__LOADED_LIB_LOCK:-}" ] && . "${LIB_DIR}/lock.sh"
[ -z "${__LOADED_LIB_LOG:-}" ] && . "${LIB_DIR}/log.sh"
[ -z "${__LOADED_LIB_PKGMGR:-}" ] && . "${LIB_DIR}/pkgmgr.sh"
[ -z "${__LOADED_LIB_SVCMGR:-}" ] && . "${LIB_DIR}/svcmgr.sh"

# ----------------------------------------------------------------
# General config
# ----------------------------------------------------------------
# If config, edge-cd.sh or edge-cd.service files change we restart
# the process (exit 0)
#
# Please note that CONFIG_PATH must be specifed

__DEFAULT_EDGE_CD_REPO_BRANCH=main
__DEFAULT_EDGE_CD_REPO_DESTINATION_PATH=/usr/local/src/edge-cd
__DEFAULT_EDGE_CD_REPO_URL=https://github.com/alexandremahdhaoui/edge-cd.git

__DEFAULT_EDGE_CD_COMMIT_PATH=/tmp/edge-cd/edge-cd-last-synchronized-commit.txt
__DEFAULT_CONFIG_COMMIT_PATH=/tmp/edge-cd/config-last-synchronized-commit.txt

__DEFAULT_CONFIG_REPO_BRANCH=main
__DEFAULT_CONFIG_REPO_DEST_PATH=/usr/local/src/edge-cd-config
__DEFAULT_CONFIG_SPEC_FILE=spec.yaml

function declare_config() {
	# -- declare vars
	declare CONFIG_PATH
	declare CONFIG_SPEC_FILE
	declare CONFIG_REPO_BRANCH
	declare CONFIG_REPO_DEST_PATH
	declare CONFIG_REPO_URL

	declare EDGE_CD_REPO_BRANCH
	declare EDGE_CD_REPO_DESTINATION_PATH
	declare EDGE_CD_REPO_URL

	declare EDGE_CD_COMMIT_PATH
	declare CONFIG_COMMIT_PATH

	# -- declare backup vars
	declare __BACKUP_CONFIG_PATH
	declare __BACKUP_CONFIG_SPEC_FILE
	declare __BACKUP_CONFIG_REPO_DEST_PATH
	declare __BACKUP_CONFIG_REPO_URL

	declare __BACKUP_EDGE_CD_REPO_BRANCH
	declare __BACKUP_EDGE_CD_REPO_DESTINATION_PATH
	declare __BACKUP_EDGE_CD_REPO_URL

	declare __BACKUP_EDGE_CD_COMMIT_PATH
	declare __BACKUP_CONFIG_COMMIT_PATH
}

function init_config() {
	# First, initialize the critical variables needed for get_config_spec_abspath()
	# These need to be set before set_extra_envs() is called
	CONFIG_SPEC_FILE="${CONFIG_SPEC_FILE:-${__DEFAULT_CONFIG_SPEC_FILE}}"
	CONFIG_REPO_DEST_PATH="${CONFIG_REPO_DEST_PATH:-${__DEFAULT_CONFIG_REPO_DEST_PATH}}"

	# CONFIG_PATH must be provided - no default
	if [[ -z "${CONFIG_PATH}" ]]; then
		echo "[ERROR] CONFIG_PATH environment variable must be set" >&2
		exit 1
	fi

	# Now we can safely call set_extra_envs since the path variables are initialized
	set_extra_envs

	# -- user config
	__BACKUP_CONFIG_PATH="${CONFIG_PATH}"
	__BACKUP_CONFIG_SPEC_FILE="$(read_value CONFIG_SPEC_FILE '.config.spec' "${__DEFAULT_CONFIG_SPEC_FILE}")"
	__BACKUP_CONFIG_REPO_BRANCH="$(read_value CONFIG_REPO_BRANCH '.config.repo.branch' "${__DEFAULT_CONFIG_REPO_BRANCH}")"
	__BACKUP_CONFIG_REPO_DEST_PATH="$(read_value CONFIG_REPO_DEST_PATH '.config.repo.destPath' "${__DEFAULT_CONFIG_REPO_DEST_PATH}")"
	__BACKUP_CONFIG_REPO_URL="$(read_value CONFIG_REPO_URL '.config.repo.url')"

	# -- edge config
	__BACKUP_EDGE_CD_REPO_BRANCH="$(read_value EDGE_CD_REPO_BRANCH '.edgeCD.repo.branch' "${__DEFAULT_EDGE_CD_REPO_BRANCH}")"
	__BACKUP_EDGE_CD_REPO_DESTINATION_PATH="$(read_value EDGE_CD_REPO_DESTINATION_PATH '.edgeCD.repo.destinationPath' "${__DEFAULT_EDGE_CD_REPO_DESTINATION_PATH}")"
	__BACKUP_EDGE_CD_REPO_URL="$(read_value EDGE_CD_REPO_URL '.edgeCD.repo.url' "${__DEFAULT_EDGE_CD_REPO_URL}")"

	__BACKUP_EDGE_CD_COMMIT_PATH="$(read_value EDGE_CD_COMMIT_PATH '.edgeCD.commitPath' "${__DEFAULT_EDGE_CD_COMMIT_PATH}")"
	__BACKUP_CONFIG_COMMIT_PATH="$(read_value CONFIG_COMMIT_PATH '.config.commitPath' "${__DEFAULT_CONFIG_COMMIT_PATH}")"
}

function reset_config() {
	reset_extra_envs

	CONFIG_PATH="${__BACKUP_CONFIG_PATH}"
	CONFIG_SPEC_FILE="${__BACKUP_CONFIG_SPEC_FILE}"

	CONFIG_REPO_BRANCH="${__BACKUP_CONFIG_REPO_BRANCH}"
	CONFIG_REPO_DEST_PATH="${__BACKUP_CONFIG_REPO_DEST_PATH}"
	CONFIG_REPO_URL="${__BACKUP_CONFIG_REPO_URL}"

	EDGE_CD_REPO_BRANCH="${__BACKUP_EDGE_CD_REPO_BRANCH}"
	EDGE_CD_REPO_DESTINATION_PATH="${__BACKUP_EDGE_CD_REPO_DESTINATION_PATH}"
	EDGE_CD_REPO_URL="${__BACKUP_EDGE_CD_REPO_URL}"

	EDGE_CD_COMMIT_PATH="${__BACKUP_EDGE_CD_COMMIT_PATH}"
	CONFIG_COMMIT_PATH="${__BACKUP_CONFIG_COMMIT_PATH}"
}

# ----------------------------------------------------------------
# R(un)T(ime) V(ariables) (RTV_)
# ----------------------------------------------------------------

function declare_runtime_variables() {
	declare RTV_REQUIRE_SERVICE_RESTART
	declare RTV_REQUIRE_SELF_RESTART
	declare RTV_REQUIRE_REBOOT
}

function reset_runtime_variables() {
	RTV_REQUIRE_SERVICE_RESTART=""
	RTV_REQUIRE_SELF_RESTART=false
	RTV_REQUIRE_REBOOT=false
}

# ----------------------------------------------------------------
# EdgeCD repo
# ----------------------------------------------------------------

function clone_repo_edge_cd() {
	logInfo "Cloning EdgeCD repo"
	git clone --filter=blob:none --no-checkout "${EDGE_CD_REPO_URL}" "${EDGE_CD_REPO_DESTINATION_PATH}"

	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout init
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout set "cmd/edge-cd"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" checkout "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" fetch origin "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" pull
}

function sync_repo_edge_cd() {
	logInfo "Pulling EdgeCD repo"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" sparse-checkout set "cmd/edge-cd"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" fetch origin "${EDGE_CD_REPO_BRANCH}"
	git -C "${EDGE_CD_REPO_DESTINATION_PATH}" reset --hard FETCH_HEAD
}

# ----------------------------------------------------------------
# Config repo
# ----------------------------------------------------------------

function clone_repo_config() {
	if [[ "${CONFIG_REPO_URL}" == "file://"* ]]; then
		logInfo "Using local file-based repository for config. This is a non-production option. Skipping git clone."
		return 0
	fi
	logInfo "Cloning config repo"
	git clone --filter=blob:none --no-checkout "${CONFIG_REPO_URL}" "${CONFIG_REPO_DEST_PATH}"

	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout init
	# Set sparse-checkout to include the config path directory
	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout set "${CONFIG_PATH}"
	git -C "${CONFIG_REPO_DEST_PATH}" checkout "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" fetch origin "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" pull
}

function sync_repo_config() {
	if [[ "${CONFIG_REPO_URL}" == "file://"* ]]; then
		logInfo "Using local file-based repository for config. This is a non-production configuration option. Skipping git pull."
		return 0
	fi
	logInfo "Pulling config repo"
	# Set sparse-checkout to include the config path directory
	git -C "${CONFIG_REPO_DEST_PATH}" sparse-checkout set "${CONFIG_PATH}"
	git -C "${CONFIG_REPO_DEST_PATH}" fetch origin "${CONFIG_REPO_BRANCH}"
	git -C "${CONFIG_REPO_DEST_PATH}" reset --hard FETCH_HEAD
}

# ----------------------------------------------------------------
# reconcile_files
# ----------------------------------------------------------------

function __reconcile_file() {
	local srcPath="${1}"
	local destPath="${2}"
	local fileMod="${3}"
	local restartServices="${4}"
	local requireReboot="${5}"

	# -- validate inputs
	if [ -z "${srcPath}" ] || [ "${srcPath}" == "null" ]; then
		logErr "srcPath must be specified"
		exit 1
	fi

	if [ -z "${destPath}" ] || [ "${destPath}" == "null" ]; then
		logErr "srcPath must be specified"
		exit 1
	elif ! echo "${destPath}" | grep -q '^/'; then
		logErr "destPath must be an absolute path"
		exit 1
	fi

	# -- set defaults
	if [ -z "${fileMod}" ] || [ "${fileMod}" == "null" ]; then fileMod=644; fi
	if [ "${restartServices}" == "null" ]; then restartServices=""; fi

	# -- compare src and dest
	if cmp "${srcPath}" "${destPath}"; then
		return 0
	fi

	logInfo "Drift detected: updating file \"${destPath}\""
	mkdir -p "$(dirname "${destPath}")"
	# mark associated service for restart
	local service
	local -a servicesToRestart
	readarray -t servicesToRestart < <(echo "${restartServices}" | yq -e -r '.[]' || true)

	for service in "${servicesToRestart[@]}"; do
		set +u
		echo $service
		RTV_REQUIRE_SERVICE_RESTART+="${service}\n"
		set -u
	done

	# -- set require reboot flag
	if [[ "${requireReboot}" == "true" ]]; then
		RTV_REQUIRE_REBOOT=true
	fi

	cp -f "${srcPath}" "${destPath}"
	chmod "${fileMod}" "${destPath}"
}

function __reconcile_file_mux() {
	local fileSpec="${1}"

	local type srcPath content destPath fileMod restartServices requireReboot
	type="$(read_yaml_stdin '.type' "${fileSpec}")"

	case "${type}" in
		file | directory)
			srcPath="$(read_yaml_stdin '.srcPath' "${fileSpec}")"
			;;
		content)
			content="$(read_yaml_stdin '.content' "${fileSpec}")"
			;;
		*)
			logErr "Unknown type=\"${type}\" for destPath=\"${destPath}\""
			exit 1
			;;
	esac

	destPath="$(read_yaml_stdin '.destPath' "${fileSpec}")"
	fileMod="$(read_yaml_stdin_optional '.fileMod' "${fileSpec}")"
	restartServices="$(read_yaml_stdin_optional '.syncBehavior.restartServices' "${fileSpec}")"
	requireReboot="$(read_yaml_stdin_optional '.syncBehavior.reboot' "${fileSpec}")"

	# TODO: Add a "git" type? E.g.: clone any repo and copy file from repo to the dest
	case "${type}" in
		file)
			srcPath="${CONFIG_REPO_DEST_PATH}/${CONFIG_PATH}/${srcPath}"
			;;

		# -- directory does not support recursive
		directory)
			find "${srcPath}" -type f ! -name '\.*' -exec readlink -f {} \; | while IFS= read -r srcPath; do
				__reconcile_file "${srcPath}" "${destPath}" "${fileMod}" "${restartServices}" "${requireReboot}"
			done
			# -- directory returns early
			return
			;;

		content)
			# -- type content
			srcPath="$(mktemp)"
			echo "${content}" | tee &>/dev/null "${srcPath}"
			;;

		*)
			logErr "Unknown type=\"${type}\" for destPath=\"${destPath}\""
			exit 1
			;;
	esac

	# -- sync file
	__reconcile_file "${srcPath}" "${destPath}" "${fileMod}" "${restartServices}" "${requireReboot}"
}

# ----------------------------------------------------------------
# sync_file_list
# ----------------------------------------------------------------

function reconcile_files() {
	logInfo "Reconciling files"

	local -a files
	readarray files < <(yq e -o=j -I=0 '.files[]' "$(get_config_spec_abspath)")

	local fileSpec
	for fileSpec in "${files[@]}"; do
		__reconcile_file_mux "${fileSpec}"
	done
}

# ----------------------------------------------------------------
# sync_edge_cd
# ----------------------------------------------------------------

function reconcile_edge_cd() {
	logInfo "Reconciling EdgeCD"

	local name=edge-cd
	local lastCommit currentCommit

	# -- Get last synced commit and current commit
	lastCommit=$(cat "${EDGE_CD_COMMIT_PATH}" 2>/dev/null || echo "")
	currentCommit="$(git -C "${EDGE_CD_REPO_DESTINATION_PATH}" rev-parse HEAD)"

	# -- Check if edge-cd script has changed between commits
	if [ -n "${lastCommit}" ] && [ "${lastCommit}" != "${currentCommit}" ]; then
		if git -C "${EDGE_CD_REPO_DESTINATION_PATH}" diff --name-only "${lastCommit}" "${currentCommit}" | grep -q "^cmd/edge-cd/edge-cd$"; then
			logInfo "EdgeCD script has changed, marking service for restart"
			RTV_REQUIRE_SERVICE_RESTART+="${name}\n"
		fi
	fi

	# -- Ensure edge-cd service is always enabled (if service file exists)
	if [ -f "/etc/init.d/${name}" ]; then
		enable_service "${name}"
	else
		logInfo "Service file /etc/init.d/${name} does not exist, skipping service enable"
	fi

	# -- Commit this change
	mkdir -p "$(dirname "${EDGE_CD_COMMIT_PATH}")"
	echo "${currentCommit}" | tee "${EDGE_CD_COMMIT_PATH}" &>/dev/null
}

# ----------------------------------------------------------------
# checkCommit
# ----------------------------------------------------------------

function is_commit_in_sync() {
	if [[ "${CONFIG_REPO_URL}" == "file://"* ]]; then
		logInfo "Using local file-based repository for config. Skipping commit synchronization."
		return 1 # Return non-zero status to signal skip
	fi
	local currentCommit lastCommit
	lastCommit=$(cat "${CONFIG_COMMIT_PATH}" 2>/dev/null || echo "")
	currentCommit="$(git -C "${CONFIG_REPO_DEST_PATH}" rev-parse HEAD)"

	if [ "${lastCommit}" == "${currentCommit}" ]; then
		logInfo "Skipping synchronization: user config is already in sync with commit ${currentCommit}"
		return 1 # Return non-zero status to signal skip
	fi

	logInfo "Starting configuration synchronization for commit ${currentCommit}"
}

function commit_last_change() {
	local currentCommit
	currentCommit="$(git -C "${CONFIG_REPO_DEST_PATH}" rev-parse HEAD)"
	echo "${currentCommit}" | tee &>/dev/null "${CONFIG_COMMIT_PATH}"
	logInfo "Synced commit \"${currentCommit}\" successfully"
}

# ----------------------------------------------------------------
# polling_backoff
# ----------------------------------------------------------------

function polling_backoff() {
	local sleepTime
	sleepTime="$(read_config '.pollingIntervalSecond' || echo "")"
	if [ -z "${sleepTime}" ]; then
		logWarn "Failed to read pollingIntervalSecond from config: Sleeping 60s" >&2
		sleepTime=60
	fi

	logInfo "Sleeping for ${sleepTime} seconds"
	sleep "${sleepTime}"
}

# ----------------------------------------------------------------
# Reconcile
# ----------------------------------------------------------------

function reconcile() {
	[ -d "${EDGE_CD_REPO_DESTINATION_PATH}" ] || clone_repo_edge_cd
	sync_repo_edge_cd

	[ -d "${CONFIG_REPO_DEST_PATH}" ] || clone_repo_config
	sync_repo_config

	# Check if the repository has been updated since the last
	# successful sync.
	if ! is_commit_in_sync; then
		# only re-install packages on new commits as drift detection
		# is not yet implemented
		reconcile_packages
	fi

	reconcile_package_auto_upgrade
	reconcile_edge_cd
	reconcile_files

	# -- Reboot if flag set
	if [ "${RTV_REQUIRE_REBOOT}" == "true" ]; then
		logInfo "Rebooting now"
		reboot
	fi

	# -- restart services
	local -a servicesToRestart
	readarray -t servicesToRestart < <(echo -e "${RTV_REQUIRE_SERVICE_RESTART}" | grep -v '^\s*$' | sort | uniq)

	for service in "${servicesToRestart[@]}"; do
		enable_service "${service}"
		restart_service "${service}"
	done
}

# ----------------------------------------------------------------
# main
# ----------------------------------------------------------------

function main() {
	lock
	trap unlock EXIT

	declare_runtime_variables
	declare_config
	init_config
	set_extra_envs

	while true; do
		reset_config
		reset_extra_envs
		reset_runtime_variables

		reconcile

		polling_backoff
	done
}

main
